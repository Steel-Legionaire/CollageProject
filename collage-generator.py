from PIL import Image
import ast
import numpy as np
from datetime import datetime

startDate = datetime.now()

# Define parameters for the collage 

# The bigger the resolution the larger each image in the collage will be
resolution = 10

# Path to input image
inputImage = "helldiver.png"

#Path to input images
inputImagesPath = "testImages"


completedNum = 0
tolerance = 10

def progress_bar(iteration, total, prefix='', suffix='', length=50, fill='â–ˆ'):
    """
    Displays a progress bar in the terminal.
    iteration: current iteration
    total: total iterations
    prefix: prefix string
    suffix: suffix string
    length: character length of the bar
    fill: character used to fill the progress bar
    """
    percent = ("{0:.1f}").format(100 * (iteration / float(total)))
    filled_length = int(length * iteration // total)
    bar = fill * filled_length + '-' * (length - filled_length)
    print ("\033[A \033[A")
    print(f'\r{prefix} |{bar}| {percent}% {suffix}', end="")

# Reading in the txt file generated by the picsum_downloader.py
# Since it is a string we are using a literal evalutaion to get an array of tuples
# The index of a tupel corrisponds to the image with the same number at the end of its file name
with open(f"{inputImagesPath}/avg_rgb_values.txt", "r") as file:
    allRgbVals = ast.literal_eval(file.readline())

img = Image.open(inputImage)
#img.show()

output_img = Image.new('RGB', (int(img.width/resolution) * resolution, int(img.height/resolution) * resolution))

total = int(img.height/resolution) * int(img.width/resolution)

for y in range(int(img.height/resolution)):
    for x in range(int(img.width/resolution)):
        crop_dimensions = (x*resolution, y*resolution, x*resolution+resolution, y*resolution+resolution)

        cropped_image = img.crop(crop_dimensions)

        # Find best matching image to replace it
        foundImage = False
        currentRGBindex = 0
        imagesIndex = 0

        while(not(foundImage)):
            currentRGBVals = allRgbVals[currentRGBindex]

            cropped_image = cropped_image.convert('RGB')

            # Retrieve the width and height of the image.
            width, height = cropped_image.size

            # Initialize a list to store RGB values.
            rgb_values = []

            # Use a list comprehension to populate the list with RGB values of each pixel.
            rgb_values = [cropped_image.getpixel((x, y)) for y in range(height) for x in range(width)]

            averageRgbValues = (0, 0, 0)
            totalRgbValues = (0, 0, 0)

            counter = 0

            for val in rgb_values:
                totalRgbValues = (totalRgbValues[0] + val[0], totalRgbValues[1] + val[1], totalRgbValues[2] + val[2])

                counter+=1

            croppedImageAverageRgbValues = (int(totalRgbValues[0] / counter), int(totalRgbValues[1] / counter), int(totalRgbValues[2] / counter))

            #print((currentRGBVals[1] - croppedImageAverageRgbValues[1] <= tolerance))
            #print((currentRGBVals[2] - croppedImageAverageRgbValues[2] <= tolerance))

            if((abs(currentRGBVals[0] - croppedImageAverageRgbValues[0]) <= tolerance) and (abs(currentRGBVals[1] - croppedImageAverageRgbValues[1]) <= tolerance) and (abs(currentRGBVals[2] - croppedImageAverageRgbValues[2]) <= tolerance)):
                
                selectedImg = Image.open(f"{inputImagesPath}/picsumImg{currentRGBindex}.png")

                selectedImg = selectedImg.resize( (resolution, resolution) )

                #print(f"Cropped RGB: {croppedImageAverageRgbValues}\nSelected Image RGB: {currentRGBVals}\n")
                #print(currentRGBindex)
                

                output_img.paste(selectedImg, (x*resolution, y*resolution))
                output_img.save("output.png")

                foundImage = True
                tolerance=10
                completedNum+=1
                progress_bar(completedNum, total, 'Generating:', 'Complete')
                #print(f"Completed {completedNum}/{total}")

            currentRGBindex+=1

            if(currentRGBindex >= len(allRgbVals)):
                #print("Error")
                currentRGBindex=0
                tolerance+=5
            
            

        
        #print(crop_dimensions)
        
        
        #cropped_image.show()

output_img.show()
print(f"\nElapsed Time: {int((datetime.now().timestamp() - startDate.timestamp()))/60}m")
