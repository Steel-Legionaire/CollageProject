from PIL import Image
import ast
import numpy as np
from datetime import datetime
import threading
import signal
import sys
import cv2
import os


startDate = datetime.now()

# ====================== CONFIG ======================
INPUT_IMAGE = "galaxy.png"
INPUT_IMAGES_PATH = "testImages"
#SCALE = 100 # How many images per pixel of the input image
RESOLUTION = 5  # Size of each tile
useCache = True
# ====================================================


def progress_bar(iteration, total, prefix='', suffix='', length=50, fill='█'):
    """
    Displays a progress bar in the terminal.
    iteration: current iteration
    total: total iterations
    prefix: prefix string
    suffix: suffix string
    length: character length of the bar
    fill: character used to fill the progress bar
    """
    percent = ("{0:.1f}").format(100 * (iteration / float(total)))
    filled_length = int(length * iteration // total)
    bar = fill * filled_length + '-' * (length - filled_length)
    print(f'\r{prefix} |{bar}| {percent}% {suffix}', end='', flush=True)

def cacheInputImages():
    cache = []
    counter=0
    for filename in os.listdir(INPUT_IMAGES_PATH):
        if filename.lower().endswith(".png"):
            imgPath = os.path.join(INPUT_IMAGES_PATH, f"picsumImg{counter}.png")
            cache.append(Image.open(imgPath))
            counter+=1
    
    return cache

def computeAvgRGB(img):

    # Convert img to a numpy array
    img_arr = np.array(img)

    # Get average across both axises and all three channels
    average_color = np.mean(img_arr, axis=(0, 1))

    # Assign each channel to the color 
    r, g, b = int(average_color[0]), int(average_color[1]), int(average_color[2])

    return(r, g, b)

def findBestMatch(avg_rgb, all_rgb_vals, tolerance):

    # Convert target RGB tuple to NumPy array
    avg_rgb = np.array(avg_rgb)
    
    # Convert list of RGB tuples to a 2D NumPy array
    all_rgb_vals = np.array(all_rgb_vals)
    
    while True:
        # Compute absolute differences between target and all RGB values
        diff = np.abs(all_rgb_vals - avg_rgb)  # Shape: (num_colors, 3)
        
        # Check if all channels are within the tolerance
        mask = np.all(diff <= tolerance, axis=1)
        elapsedSeconds = int(((datetime.now() - startDate).total_seconds() / 60) *100)
        if np.any(mask):
            return np.argmax(mask)  # Return the index of the first match
        
        # If no match is found, increase tolerance
        tolerance += 5


def createCollage(img):
    
    completedNum = 0
    tolerance = 10

    output_img = Image.new('RGB', (int(img.width/RESOLUTION)*RESOLUTION, int(img.height/RESOLUTION)*RESOLUTION))

    for y in range(int(img.height/RESOLUTION)):
        for x in range(int(img.width/RESOLUTION)):

            # Crop image and convert
            crop_dimensions = (x*RESOLUTION, y*RESOLUTION, x*RESOLUTION+RESOLUTION, y*RESOLUTION+RESOLUTION)
            cropped_image = img.crop(crop_dimensions)
            cropped_image = cropped_image.convert('RGB')

            # Get its avg rgb
            croppedImageAverageRgbValues = computeAvgRGB(cropped_image)

            # Search for a best match
            bestMatchIndex = findBestMatch(croppedImageAverageRgbValues, allRgbVals, tolerance)
                
            # Open and resize selected image
            if(useCache):
                selectedImg = cahcedImages[bestMatchIndex]
            else:
                selectedImg = Image.open(f"{INPUT_IMAGES_PATH}/picsumImg{bestMatchIndex}.png")
            
            selectedImg = selectedImg.resize( (RESOLUTION, RESOLUTION) )

            # Paste it to the output
            output_img.paste(selectedImg, (x*RESOLUTION, y*RESOLUTION))
            
            # Increment how many sections completed
            completedNum+=1

            # Update the progress bar
            progress_bar(completedNum, total, 'Generating:', 'Complete')      

    return output_img  

# Reading in the txt file generated by the picsum_downloader.py
# Since it is a string we are using a literal evalutaion to get an array of tuples
# The index of a tupel corrisponds to the image with the same number at the end of its file name
with open(f"{INPUT_IMAGES_PATH}/avg_rgb_values.txt", "r") as file:
    allRgbVals = ast.literal_eval(file.readline())

inputImg = Image.open(INPUT_IMAGE)
total = int(inputImg.height/RESOLUTION) * int(inputImg.width/RESOLUTION)

if(useCache):
    cahcedImages = cacheInputImages()

finalImg = createCollage(inputImg)

savePath = f"{INPUT_IMAGE.strip(".png")}-collage.png"

finalImg.save(savePath)
finalImg.show()

elapsedSeconds = (datetime.now() - startDate).total_seconds()

print(f"\n✅ Elapsed Time: {elapsedSeconds:.0f} seconds")